"""
C. Каждому по компьютеру
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

В новом учебном году на занятия в компьютерные классы Дворца Творчества Юных
пришли учащиеся, которые были разбиты на N групп. В i-й группе оказалось Xi
человек. Тут же перед директором встала серьезная проблема: как распределить
группы по аудиториям. Во дворце имеется M ≥ N аудиторий, в j-й аудитории
имеется Yj компьютеров. Для занятий необходимо, чтобы у каждого учащегося был
компьютер и еще один компьютер был у преподавателя. Переносить компьютеры из
одной аудитории в другую запрещается. Помогите директору!

Напишите программу, которая найдет, какое максимальное количество групп удастся
одновременно распределить по аудиториям, чтобы всем учащимся в каждой группе
хватило компьютеров, и при этом остался бы еще хотя бы один для учителя.

Формат ввода
На первой строке входного файла расположены числа N и M (1 ≤ N ≤ M ≤ 1000).
На второй строке расположено N чисел — X1, …, XN
(1 ≤ Xi ≤ 1000 для всех 1 ≤ i ≤ N).
На третьей строке расположено M чисел Y1, ..., YM
(1 ≤ Yi ≤ 1000 для всех 1 ≤ i ≤ M).

Формат вывода
Выведите на первой строке число P - количество групп, которые удастся
распределить по аудиториям. На второй строке выведите распределение групп по
аудиториям – N чисел, i-е число должно соответствовать номеру аудитории, в
которой должна заниматься i-я группа.
(Нумерация как групп, так и аудиторий, начинается с 1). Если
i-я группа осталась без аудитории, i-е число должно быть равно 0. Если
допустимых распределений несколько, выведите любое из них.

Пример 1
Ввод	Вывод
1 1
1
2
        1
        1
Пример 2
Ввод	Вывод
1 1
1
1
        0
        0
"""

N, M = list(map(int, input().strip().split(" ")))
required_cnt = list(map(lambda x: int(x) + 1, input().strip().split(" ")))
available_cnt = list(map(int, input().strip().split(" ")))

req_sort = sorted(zip(required_cnt, range(N)))
avail_sort = sorted(zip(available_cnt, range(1, M + 1)))


i = j = 0

classes = [0] * N
success_cnt = 0
for i in range(N):
    while j < M and req_sort[i][0] > avail_sort[j][0]:
        j += 1
    if j < M:
        classes[req_sort[i][1]] = avail_sort[j][1]
        success_cnt += 1
        j += 1

print(success_cnt)
for c in classes:
    print(c)
